import os
import sys
from subprocess import call
import json
import shutil

if __name__ != "__main__":
	exit()

jar_files = []
with os.scandir() as iterator:
	for file in iterator:
		if file.name.endswith(".jar") and file.is_file():
			jar_files.append(file);

if len(jar_files) == 0:
	print("No jar files found")
	sys.exit(1)

print("Which jar file do you want to extract the data from?\n")
for i in range(len(jar_files)):
	print("\t[" + str(i) + "] " + jar_files[i].name)

file_num = input("\nEnter file number: ")
try:
	input_num = int(file_num)
	is_int = True
except:
	is_int = False

while not is_int or ( input_num < 0 or input_num >= len(jar_files)):
	print("There is no file numbered '" + str(file_num) +"'")
	file_num = input("\nEnter file number: ")
	try:
		input_num = int(file_num)
		is_int = True
	except:
		is_int = False



jar_file = jar_files[input_num].name
command = ["java", "-cp", jar_file, "net.minecraft.data.Main", "--reports"]
run_code = call(command)
if run_code != 0:
	print("Error extracting contents")
	sys.exit(1)

blocks_json = open("generated\\reports\\blocks.json", "r")
blocks = json.load(blocks_json)
blocks_json.close()
new_blocks = {}

for block in blocks.keys():
	blocks[block].pop("states", None)
	if not "properties" in blocks[block]:
		blocks[block]["properties"] = {}
	if block.startswith("minecraft:"):
		new_block = block[10:]
	else:
		new_block = block
	new_blocks[new_block] = blocks[block]

blocks_py = open("Blocks.py", "w")
blocks_py.write("# File automatically generated by UpdateAll.py\n")
blocks_py.write("BLOCKS = " + str(new_blocks))
blocks_py.close()

commands_json = open("generated\\reports\\commands.json", "r")
commands_json_raw = commands_json.read()
commands = json.loads(commands_json_raw)
commands_json.close()

commands["children"]["execute"]["children"]["run"]["redirect"] = ["root"]
commands["children"]["playsound"]["children"]["sound"]["parser"] = "minecraft:sound"

known_parsers = { # Master list of what function the parser name in commands.json corresponds to
	"minecraft:resource_location" : False,
	"minecraft:function" : False,
	"minecraft:entity" : False,
	"brigadier:string" : False, #type  = word and type= greedy
	"minecraft:game_profile" : False,
	"minecraft:message" : False,
	"minecraft:block_pos" : False,
	"minecraft:nbt_compound_tag" : False,
	"minecraft:item_stack" : False,
	"minecraft:item_predicate" : False,
	"brigadier:integer" : False, #Properties has min and max
	"minecraft:block_state" : False,
	"minecraft:block_predicate" : False,
	"minecraft:nbt_path" : False,
	"brigadier:float" : False,
	"brigadier:double" : False,
	"brigadier:bool" : False,
	"minecraft:swizzle"  : False, # any cobination of x, y, and z e.g. x, xy, xz. AKA swizzle
	"minecraft:score_holder" : False, #Has options to include wildcard or not
	"minecraft:objective" : False,
	"minecraft:vec3" : False,
	"minecraft:vec2" : False,
	"minecraft:particle" : False,
	"minecraft:item_slot" : False, #Check the wiki on this one I guess
	"minecraft:scoreboard_slot" : False,
	"minecraft:team" : False,
	"minecraft:color" : False,
	"minecraft:rotation" : False, # [yaw, pitch], includes relative changes
	"minecraft:component" : False,
	"minecraft:entity_anchor" : False,
	"minecraft:operation" : False, # +=, = , <>, etc
	"minecraft:int_range" : False,
	"minecraft:mob_effect" : False,
	"minecraft:sound" : False,
	"minecraft:objective_criteria" : False,
	"minecraft:entity_summon" : False,
	"minecraft:item_enchantment" : False,
	"minecraft:dimension" : False,
	"minecraft:column_pos" : False,
	"minecraft:time" : False,
	"minecraft:nbt_tag" : False
}

new_parsers = []

def find_new_parsers(command_tree):
	if "type" in command_tree and command_tree["type"] == "argument":
		parser = command_tree["parser"]
		if not parser in known_parsers and not parser in new_parsers:
			new_parsers.append(parser)
		else:
			known_parsers[parser] = True

	if "children" in command_tree:
		for child in command_tree["children"]:
			find_new_parsers(command_tree["children"][child])

find_new_parsers(commands)
if len(new_parsers) > 0:
	print("New parsers found: ")
	for parser in new_parsers:
		print("\t" + parser)

print("Unused parsers: ")
found_unused = False
for parser in known_parsers.keys():
	if not known_parsers[parser]:
		found_unused = True
		print("\t" + parser)

if not found_unused:
	print("\tNone")

commands_py = open("CommandTree.py", "w")
commands_py.write("# File automatically generated by UpdateAll.py\n")
commands_py.write("COMMAND_TREE = " + str(commands))
commands_py.close()

commands_json_raw_file = open("commands.json", "w")
commands_json_raw_file.write(commands_json_raw)
commands_json_raw_file.close()

registries_json = None
with open("generated\\reports\\registries.json") as file:
	registries_json = json.load(file)

def save_registries(file, registries_json, var_name_map):
	for var_name, entry_name in var_name_map.items():
		registry_raw = registries_json[entry_name]["entries"]
		registry = [name[10:] for name, _ in registry_raw.items()]
		file.write(var_name + " = frozenset(" + str(set(registry)) + ")\n")

registry_names = {
	"ITEMS" : "minecraft:item",
	"POTIONS" : "minecraft:mob_effect",
	"ENCHANTMENTS" : "minecraft:enchantment",
	"CUSTOM_STATS" : "minecraft:custom_stat",
	"PARTICLES" : "minecraft:particle_type",
	"SOUNDS" : "minecraft:sound_event"
}

registries_py = open("Registries.py", "w")
registries_py.write("# File automatically generated by UpdateAll.py\n")
save_registries(registries_py, registries_json, registry_names)
registries_py.close()

shutil.rmtree("generated")
shutil.rmtree("logs")

#java -cp minecraft_server.%version%.jar net.minecraft.data.Main --all
